import update from 'immutability-helper';
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { IAuth, ILayout, IProduct, IProductsState } from '../../app/types';
import { removeBearerFromFetchService, setBearerToFetchService } from '../../common/services/fetch';
import { getTokenFromCookie, removeTokenFromCookie, setTokenToCookie } from '../../common/utils';
import { addProduct, deleteProduct, getProducts, updateProduct } from './productsAPI';

// This is the global state. App-wide states will be store here
const initialState: IProductsState = {
    products: [],
    isLoading: false,
    error: null,
    layout: 'grid',
    add: {
        isSuccess: false,
        error: null,
        isLoading: false,
    },
    update: {
        isSuccess: false,
        product: null,
        error: null,
        isLoading: false,
    },
    delete: {
        loadingProductId: null,
    },
};

const productsSlice = createSlice({
    name: 'products-slice',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setLayout: (state, action: PayloadAction<ILayout>) => {
            state.layout = action.payload;
        },
        resetAddStates: state => {
            state.add = initialState.add;
        },
        openUpdateProductModal: (state, action: PayloadAction<IProduct>) => {
            state.update.product = action.payload;
        },
        closeUpdateProductModal: state => {
            state.update = initialState.update;
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: builder => {
        builder
            // getProducts async action handler
            .addCase(getProducts.pending, state => {
                state.products = [];
                state.isLoading = true;
                state.error = null;
            })
            .addCase(getProducts.fulfilled, (state, action: PayloadAction<IProduct[]>) => {
                state.isLoading = false;
                state.products = action.payload;
            })
            .addCase(getProducts.rejected, (state, action) => {
                state.isLoading = false;
                state.error = action.payload as string;
            })
            // addProduct async action handler
            .addCase(addProduct.pending, state => {
                state.add.isSuccess = false;
                state.add.isLoading = true;
                state.add.error = null;
            })
            .addCase(addProduct.fulfilled, (state, action: PayloadAction<IProduct>) => {
                state.add.isLoading = false;
                state.add.isSuccess = true;
                state.products.push(action.payload);
            })
            .addCase(addProduct.rejected, (state, action) => {
                state.add.isLoading = false;
                state.add.error = action.payload as string;
            })
            // update async action handlers
            .addCase(updateProduct.pending, state => {
                state.update.isSuccess = false;
                state.update.error = null;
                state.update.isLoading = true;
            })
            .addCase(updateProduct.fulfilled, (state, action: PayloadAction<IProduct>) => {
                state.update.isLoading = false;
                state.update.isSuccess = true;
                const index = state.products.findIndex(x => x.id === action.payload.id);
                state.products = update(state.products, { [index]: { $set: action.payload } });
            })
            .addCase(updateProduct.rejected, (state, action) => {
                state.update.isLoading = false;
                state.update.error = action.payload as string;
            })
            // update async action handlers
            .addCase(deleteProduct.pending, (state, { meta }) => {
                state.delete.loadingProductId = meta.arg; // the argument that is passed to action (product.id)
                state.error = null;
            })
            .addCase(deleteProduct.fulfilled, (state, action: PayloadAction<number>) => {
                state.delete.loadingProductId = null;
                const index = state.products.findIndex(x => x.id === action.payload);
                state.products = update(state.products, { $splice: [[index, 1]] });
            })
            .addCase(deleteProduct.rejected, (state, action) => {
                state.delete.loadingProductId = null;
                state.error = action.payload as string;
            });
    },
});

const { reducer: productsReducer, actions } = productsSlice;

export const { setLayout, resetAddStates, closeUpdateProductModal, openUpdateProductModal } = actions;

export default productsReducer;
